name: Sign Windows Binaries

on:
  workflow_call:
    inputs:
      artifact-pattern:
        description: 'Pattern for artifacts to download (default: terragrunt_windows_*)'
        required: false
        type: string
        default: 'terragrunt_windows_*'
      upload-artifact-name:
        description: 'Name for the uploaded signed artifacts'
        required: false
        type: string
        default: 'windows-signed-files'

jobs:
  sign-windows:
    name: Sign Windows Binaries
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download Windows build artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: ${{ inputs.artifact-pattern }}
          path: artifacts/
          merge-multiple: true

      - name: Prepare build artifacts
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path bin
          
          # --- FIX: Corrected typo 'terraggunt' to 'terragrunt' ---
          Get-ChildItem -Path artifacts -Filter "terragrunt_windows_*" -Recurse -File |
          ForEach-Object {
            Copy-Item $_.FullName -Destination bin/
          }
          Write-Host "Binary files to sign:"
          Get-ChildItem -Path bin | ForEach-Object { Write-Host $_.FullName }

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      # This step rebuilds the binaries to include Windows version metadata
      - name: Add Windows version metadata
        shell: pwsh
        run: |
          # Install goversioninfo
          Write-Host "Installing goversioninfo..."
          go install github.com/josephspurrier/goversioninfo/cmd/goversioninfo@v1.5.0

          # Add Go bin to PATH
          $goPath = & go env GOPATH
          $goBinPath = Join-Path $goPath "bin"
          $env:PATH = "$goBinPath;$env:PATH"

          # Get version
          $version = $env:GITHUB_REF_NAME
          if ([string]::IsNullOrEmpty($version) -or $version -eq "refs/heads/main") {
            $version = "0.0.0-dev"
          }
          $version = $version.TrimStart('v')

          # Parse version components
          $versionParts = $version.Split('.')
          $major = if ($versionParts.Length -gt 0) { $versionParts[0] } else { "0" }
          $minor = if ($versionParts.Length -gt 1) { $versionParts[1] } else { "0" }
          $patch = if ($versionParts.Length -gt 2) { $versionParts[2].Split('-')[0] } else { "0" }

          $fileVersion = "$major.$minor.$patch.0"
          $year = (Get-Date).Year

          Write-Host "Generating version info for: $version (FileVersion: $fileVersion)"

          # Update versioninfo.json
          $versionInfo = Get-Content versioninfo.json | ConvertFrom-Json
          $versionInfo.StringFileInfo.FileVersion = $fileVersion
          $versionInfo.StringFileInfo.ProductVersion = $version
          $versionInfo.StringFileInfo.LegalCopyright = "Copyright (C) $year Gruntwork, Inc."
          $versionInfo | ConvertTo-Json -Depth 10 | Set-Content -Path versioninfo.json

          # Generate resource file
          goversioninfo -o=rsrc.syso versioninfo.json

          # Rebuild Windows binaries with metadata
          $architectures = @("386", "amd64")
          foreach ($arch in $architectures) {
            $env:GOOS = "windows"
            $env:GOARCH = $arch
            $output = "bin\terragrunt_windows_$arch.exe"

            Write-Host "Rebuilding windows/$arch with version metadata..."
            go build -o $output `
              -ldflags "-s -w -X github.com/gruntwork-io/go-commons/version.Version=$version -extldflags '-static'" `
              .
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Build failed for windows/$arch"
              exit 1
            }

            Write-Host "✅ Built $output with metadata"
          }

          # Clean up
          if (Test-Path rsrc.syso) {
            Remove-Item rsrc.syso
          }

          Write-Host "✅ All Windows binaries rebuilt with version metadata"

      # Step 1: Install DigiCert smtools
      - name: Install DigiCert smtools
        uses: digicert/ssm-code-signing@v1.1.0
        with:
          force-download-tools: 'true'

      # Step 2: Decode certificate and configure smctl
      - name: Configure smctl authentication
        shell: pwsh
        env:
          DIGICERT_API_KEY: ${{ secrets.WINDOWS_SIGNING_API_KEY }}
          CERT_B64: ${{ secrets.WINDOWS_SIGNING_P12_BASE64 }}
          CERT_PASSWORD: ${{ secrets.WINDOWS_SIGNING_P12_PASSWORD }}
        run: |
          $ErrorActionPreference = 'Stop'

          Write-Host "Configuring smctl authentication..."

          # Validate secrets
          if ([string]::IsNullOrEmpty($env:DIGICERT_API_KEY)) {
            Write-Error "❌ WINDOWS_SIGNING_API_KEY secret is not set!"
            exit 1
          }
          if ([string]::IsNullOrEmpty($env:CERT_B64)) {
            Write-Error "❌ WINDOWS_SIGNING_P12_BASE64 secret is not set!"
            exit 1
          }
          if ([string]::IsNullOrEmpty($env:CERT_PASSWORD)) {
            Write-Error "❌ WINDOWS_SIGNING_P12_PASSWORD secret is not set!"
            exit 1
          }

          # Decode certificate to file
          Write-Host "Decoding certificate from base64..."
          $certBytes = [Convert]::FromBase64String($env:CERT_B64)
          [IO.File]::WriteAllBytes("D:\client_auth.p12", $certBytes)

          if (Test-Path "D:\client_auth.p12") {
            Write-Host "✅ Certificate file created: D:\client_auth.p12"
            $fileInfo = Get-Item "D:\client_auth.p12"
            Write-Host "   Size: $($fileInfo.Length) bytes"
          } else {
            Write-Error "❌ Failed to create certificate file"
            exit 1
          }

          # Configure smctl with authentication
          Write-Host "`nConfiguring smctl..."
          & smctl.exe config --api-token $env:DIGICERT_API_KEY --client-auth-cert "D:\client_auth.p12" --client-auth-cert-pass $env:CERT_PASSWORD

          if ($LASTEXITCODE -ne 0) {
            Write-Error "❌ smctl config failed with exit code: $LASTEXITCODE"
            exit 1
          }

          Write-Host "✅ smctl configured successfully"

          # Test authentication by listing keypairs
          Write-Host "`nTesting authentication..."
          & smctl.exe keypair ls

          if ($LASTEXITCODE -ne 0) {
            Write-Error "❌ Failed to list keypairs - authentication failed"
            exit 1
          }

          Write-Host "✅ Authentication successful"

      # Step 3: Sign binaries with smctl
      - name: Sign Windows Binaries
        shell: pwsh
        env:
          KEYPAIR_ALIAS: ${{ secrets.WINDOWS_SIGNING_KEYPAIR_ALIAS }}
        run: |
          $ErrorActionPreference = 'Stop'

          Write-Host "Signing Windows binaries with smctl..."

          # Validate keypair alias
          if ([string]::IsNullOrEmpty($env:KEYPAIR_ALIAS)) {
            Write-Error "❌ WINDOWS_SIGNING_KEYPAIR_ALIAS secret is not set!"
            exit 1
          }

          Write-Host "Keypair alias: $env:KEYPAIR_ALIAS"

          # Get binaries
          $binaries = Get-ChildItem -Path bin -Filter "terragrunt_windows_*.exe"
          if ($binaries.Count -eq 0) {
            Write-Error "❌ No Windows binaries found in bin/ directory"
            exit 1
          }

          Write-Host "`nFound $($binaries.Count) binaries to sign"

          foreach ($binary in $binaries) {
            Write-Host "`n========================================="
            Write-Host "Signing: $($binary.Name)"
            Write-Host "========================================="

            # Sign using smctl (it will use signtool internally and handle timestamping)
            & smctl.exe sign --keypair-alias $env:KEYPAIR_ALIAS --input $binary.FullName

            if ($LASTEXITCODE -ne 0) {
              Write-Error "❌ Signing failed for $($binary.Name) with exit code: $LASTEXITCODE"
              exit 1
            }

            Write-Host "✅ Successfully signed $($binary.Name)"

            # Verify signature using signtool
            Write-Host "Verifying signature..."
            $signtoolPath = Get-Command signtool.exe -ErrorAction SilentlyContinue
            if ($signtoolPath) {
              & $signtoolPath.Source verify /pa /v $binary.FullName
              if ($LASTEXITCODE -eq 0) {
                Write-Host "✅ Signature verified"
              } else {
                Write-Warning "⚠️  Signature verification warning (may be expected in CI)"
              }
            }
          }

          Write-Host "`n========================================="
          Write-Host "✅ All Windows binaries signed successfully!"
          Write-Host "========================================="

      # Step 3: Upload the signed artifacts
      - name: Upload Signed Windows Binaries
        uses: actions/upload-artifact@v5
        with:
          name: ${{ inputs.upload-artifact-name }}
          path: bin/terragrunt_windows_*.exe
          if-no-files-found: error