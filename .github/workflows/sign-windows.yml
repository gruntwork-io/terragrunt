name: Sign Windows Binaries

on:
  workflow_call:
    inputs:
      artifact-pattern:
        description: 'Pattern for artifacts to download (default: terragrunt_windows_*)'
        required: false
        type: string
        default: 'terragrunt_windows_*'
      upload-artifact-name:
        description: 'Name for the uploaded signed artifacts'
        required: false
        type: string
        default: 'windows-signed-files'

jobs:
  sign-windows:
    name: Sign Windows Binaries
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download Windows build artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: ${{ inputs.artifact-pattern }}
          path: artifacts/

      - name: Prepare build artifacts
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path bin
          Get-ChildItem -Path artifacts -Filter "terragrunt_windows_*" -Recurse -File | ForEach-Object {
            Copy-Item $_.FullName -Destination bin/
          }
          Write-Host "Binary files to sign:"
          Get-ChildItem -Path bin | ForEach-Object { Write-Host $_.FullName }

      - name: Use mise to install dependencies
        uses: jdx/mise-action@v2
        with:
          version: 2025.8.16
          experimental: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Install DigiCert Client Tools
        id: digicert_tools
        uses: digicert/ssm-code-signing@v1.1.0
        env:
          FORCE_DOWNLOAD_TOOLS: 'true'
        with:
          api-key: ${{ secrets.WINDOWS_SIGNING_API_KEY }}
          client-cert-base64: ${{ secrets.WINDOWS_SIGNING_P12_BASE64 }}
          client-cert-password: ${{ secrets.WINDOWS_SIGNING_P12_PASSWORD }}
          keypair-alias: ${{ secrets.WINDOWS_SIGNING_KEYPAIR_ALIAS }}

      - name: Verify DigiCert tools installation
        shell: pwsh
        run: |
          Write-Host "Verifying DigiCert client tools installation..."

          # Check for smctl
          $smctlPath = Get-Command smctl.exe -ErrorAction SilentlyContinue
          if ($smctlPath) {
            Write-Host "✅ smctl.exe found at: $($smctlPath.Source)"
            # Verify smctl is working (--help is a valid command)
            $null = & smctl.exe --help 2>&1
            if ($LASTEXITCODE -eq 0) {
              Write-Host "✅ smctl.exe is functional"
            }
          } else {
            Write-Error "❌ smctl.exe not found in PATH"
            exit 1
          }

          # Check for signtool
          $signtoolPath = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if ($signtoolPath) {
            Write-Host "✅ signtool.exe found at: $($signtoolPath.Source)"
          } else {
            Write-Warning "⚠️ signtool.exe not found, checking Windows SDK location..."
            $signtoolPath = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Filter "signtool.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($signtoolPath) {
              Write-Host "✅ Found signtool.exe at: $($signtoolPath.FullName)"
              $sdkBinPath = $signtoolPath.DirectoryName
              echo "SDK_BIN_PATH=$sdkBinPath" >> $env:GITHUB_ENV
              echo "$sdkBinPath" >> $env:GITHUB_PATH
            } else {
              Write-Error "❌ signtool.exe not found. Installing Windows SDK..."
              choco install windows-sdk-10-version-2004-all -y

              # Search again after installation
              $signtoolPath = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Filter "signtool.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($signtoolPath) {
                Write-Host "✅ Found signtool.exe at: $($signtoolPath.FullName)"
                $sdkBinPath = $signtoolPath.DirectoryName
                echo "SDK_BIN_PATH=$sdkBinPath" >> $env:GITHUB_ENV
                echo "$sdkBinPath" >> $env:GITHUB_PATH
              } else {
                Write-Error "❌ Failed to install or find signtool.exe"
                exit 1
              }
            }
          }

          Write-Host "✅ All required tools verified"

      - name: Generate version info resource file
        shell: pwsh
        run: |
          # Install goversioninfo with proper GOBIN configuration
          Write-Host "Installing goversioninfo..."

          # Set GOBIN explicitly to ensure install knows where to put binary
          $goPath = & go env GOPATH
          $goBinPath = Join-Path $goPath "bin"

          # Create bin directory if it doesn't exist
          if (-not (Test-Path $goBinPath)) {
            Write-Host "Creating Go bin directory: $goBinPath"
            New-Item -ItemType Directory -Path $goBinPath -Force | Out-Null
          }

          # Set GOBIN environment variable for this install
          $env:GOBIN = $goBinPath
          Write-Host "GOPATH: $goPath"
          Write-Host "GOBIN: $env:GOBIN"

          # Install goversioninfo
          go install github.com/josephspurrier/goversioninfo/cmd/goversioninfo@v1.5.0

          if ($LASTEXITCODE -ne 0) {
            Write-Error "❌ go install failed with exit code: $LASTEXITCODE"
            exit 1
          }

          Write-Host "Installation completed, checking for executable..."

          # Wait a moment for file system to sync
          Start-Sleep -Seconds 2

          # Verify the executable was created
          $goversioninfoExe = Join-Path $goBinPath "goversioninfo.exe"
          if (-not (Test-Path $goversioninfoExe)) {
            Write-Error "❌ goversioninfo.exe not found at: $goversioninfoExe"
            Write-Host "Contents of $goBinPath :"
            Get-ChildItem $goBinPath -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  $($_.Name)" }

            # Try alternative: build directly
            Write-Host "Attempting alternative installation method..."
            $tempDir = New-Item -ItemType Directory -Path (Join-Path $env:TEMP "goversioninfo-build") -Force
            Push-Location $tempDir
            go mod init temp 2>$null
            go get github.com/josephspurrier/goversioninfo/cmd/goversioninfo@v1.5.0
            go build -o $goversioninfoExe github.com/josephspurrier/goversioninfo/cmd/goversioninfo
            Pop-Location
            Remove-Item $tempDir -Recurse -Force

            if (-not (Test-Path $goversioninfoExe)) {
              Write-Error "❌ Alternative installation also failed"
              exit 1
            }
          }

          Write-Host "✅ goversioninfo.exe found at: $goversioninfoExe"

          # Add to PATH for current and future steps
          $env:PATH = "$goBinPath;$env:PATH"
          echo "$goBinPath" >> $env:GITHUB_PATH
          Write-Host "✅ Added Go bin to PATH"

          # Get version from git tag or use a default
          $version = $env:GITHUB_REF_NAME
          if ([string]::IsNullOrEmpty($version) -or $version -eq "refs/heads/main") {
            $version = "0.0.0-dev"
          }
          $version = $version.TrimStart('v')

          # Parse version into components
          $versionParts = $version.Split('.')
          $major = if ($versionParts.Length -gt 0) { $versionParts[0] } else { "0" }
          $minor = if ($versionParts.Length -gt 1) { $versionParts[1] } else { "0" }
          $patch = if ($versionParts.Length -gt 2) { $versionParts[2].Split('-')[0] } else { "0" }

          $fileVersion = "$major.$minor.$patch.0"
          $year = (Get-Date).Year

          Write-Host "Generating version info for version: $version (FileVersion: $fileVersion)"

          # Update versioninfo.json
          $versionInfo = Get-Content versioninfo.json | ConvertFrom-Json
          $versionInfo.StringFileInfo.FileVersion = $fileVersion
          $versionInfo.StringFileInfo.ProductVersion = $version
          $versionInfo.StringFileInfo.LegalCopyright = "Copyright (C) $year Gruntwork, Inc."

          $versionInfo | ConvertTo-Json -Depth 10 | Set-Content -Path versioninfo.json

          Write-Host "Updated versioninfo.json"

      - name: Rebuild Windows binaries with version info
        shell: pwsh
        run: |
          Write-Host "Rebuilding Windows binaries with version information..."

          # Verify goversioninfo is in PATH
          $goversioninfo = Get-Command goversioninfo.exe -ErrorAction SilentlyContinue
          if (-not $goversioninfo) {
            Write-Error "goversioninfo.exe not found in PATH"
            Write-Host "PATH: $env:PATH"
            exit 1
          }

          # Generate the resource file
          goversioninfo -o=rsrc.syso versioninfo.json

          # Get version
          $version = $env:GITHUB_REF_NAME
          if ([string]::IsNullOrEmpty($version)) {
            $version = "dev"
          }

          # Rebuild Windows binaries
          $architectures = @("386", "amd64")

          foreach ($arch in $architectures) {
            $env:GOOS = "windows"
            $env:GOARCH = $arch
            $output = "bin\terragrunt_windows_$arch.exe"

            Write-Host "Building for windows/$arch..."

            go build -o $output `
              -ldflags "-s -w -X github.com/gruntwork-io/go-commons/version.Version=$version -extldflags '-static'" `
              .

            if ($LASTEXITCODE -ne 0) {
              Write-Error "Build failed for windows/$arch"
              exit 1
            }

            Write-Host "Built $output"
          }

          # Clean up resource file
          if (Test-Path rsrc.syso) {
            Remove-Item rsrc.syso
          }

          Write-Host "All Windows binaries rebuilt successfully"

      - name: Sign Windows Binaries
        shell: pwsh
        env:
          DIGICERT_KEYPAIR_ALIAS: ${{ secrets.WINDOWS_SIGNING_KEYPAIR_ALIAS }}
        run: |
          Write-Host "Signing Windows binaries..."

          # Validate keypair alias is set
          if ([string]::IsNullOrEmpty($env:DIGICERT_KEYPAIR_ALIAS)) {
            Write-Error "❌ DIGICERT_KEYPAIR_ALIAS environment variable is empty"
            Write-Host "Please ensure the GitHub secret WINDOWS_SIGNING_KEYPAIR_ALIAS is set"
            Write-Host "It should contain the keypair alias from DigiCert KeyLocker (e.g., key_1028388410)"
            exit 1
          }

          Write-Host "Keypair alias: $env:DIGICERT_KEYPAIR_ALIAS"

          # Find signtool (should be in PATH after DigiCert action)
          $signtoolPath = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if (-not $signtoolPath) {
            # Fallback to SDK_BIN_PATH if set
            if ($env:SDK_BIN_PATH) {
              $signtoolPath = "$env:SDK_BIN_PATH\signtool.exe"
            } else {
              Write-Error "❌ signtool.exe not found in PATH or SDK_BIN_PATH"
              exit 1
            }
          } else {
            $signtoolPath = $signtoolPath.Source
          }

          Write-Host "Using signtool: $signtoolPath"

          # List available certificates in Windows store (for debugging)
          Write-Host "`nListing certificates in 'My' store:"
          try {
            $certOutput = & certutil -store My 2>&1
            $certOutput | Select-String -Pattern "Subject|Thumbprint|Cert Hash" | ForEach-Object { Write-Host "  $_" }
          } catch {
            Write-Warning "Could not list certificates: $_"
          }

          # Get list of Windows executables
          $binaries = Get-ChildItem -Path bin -Filter "terragrunt_windows_*.exe"

          if ($binaries.Count -eq 0) {
            Write-Error "❌ No Windows binaries found in bin/ directory"
            exit 1
          }

          Write-Host "`nFound $($binaries.Count) binaries to sign"

          foreach ($binary in $binaries) {
            Write-Host "`n========================================="
            Write-Host "Signing: $($binary.Name)"
            Write-Host "========================================="

            # Sign using signtool with DigiCert KSP
            # The certificate should already be synced by the DigiCert action
            & $signtoolPath sign `
              /sha1 $env:DIGICERT_KEYPAIR_ALIAS `
              /tr http://timestamp.digicert.com `
              /td SHA256 `
              /fd SHA256 `
              /d "Terragrunt - Terraform Wrapper" `
              $binary.FullName

            if ($LASTEXITCODE -ne 0) {
              Write-Error "❌ Signing failed for $($binary.Name) with exit code: $LASTEXITCODE"
              Write-Host "`nTroubleshooting tips:"
              Write-Host "  1. Verify keypair alias is correct: $env:DIGICERT_KEYPAIR_ALIAS"
              Write-Host "  2. Check that DigiCert action successfully synced certificates"
              Write-Host "  3. Ensure the certificate is visible in Windows certificate store above"
              Write-Host "  4. Verify network connectivity to timestamp server"
              exit 1
            }

            Write-Host "✅ Successfully signed $($binary.Name)"

            # Verify the signature
            Write-Host "Verifying signature for $($binary.Name)..."
            & $signtoolPath verify /pa /v $binary.FullName

            if ($LASTEXITCODE -ne 0) {
              Write-Warning "⚠️  Signature verification failed for $($binary.Name)"
              Write-Host "This may be expected if running on a system without the full cert chain"
            } else {
              Write-Host "✅ Signature verified successfully for $($binary.Name)"
            }
          }

          Write-Host "`n========================================="
          Write-Host "✅ All Windows binaries signed successfully!"
          Write-Host "========================================="

      - name: Upload Signed Windows Binaries
        uses: actions/upload-artifact@v5
        with:
          name: ${{ inputs.upload-artifact-name }}
          path: bin/terragrunt_windows_*.exe
          if-no-files-found: error
