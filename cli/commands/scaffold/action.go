package scaffold

import (
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/gruntwork-io/terragrunt/config"
	"github.com/gruntwork-io/terragrunt/shell"

	"github.com/gruntwork-io/terragrunt/terraform"

	"github.com/gruntwork-io/terragrunt/cli/commands/hclfmt"
	"github.com/gruntwork-io/terragrunt/util"

	boilerplate_options "github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/templates"
	"github.com/gruntwork-io/boilerplate/variables"
	"github.com/gruntwork-io/go-commons/errors"
	"github.com/gruntwork-io/terragrunt/options"
	"github.com/gruntwork-io/terratest/modules/files"
	"github.com/hashicorp/go-getter"
)

const (
	SourceUrlTypeHttps = "git-https"
	SourceUrlTypeGit   = "git-ssh"
	SourceGitSshUser   = "git"

	defaultBoilerplateConfig = `
variables:

`
	defaultTerragruntTemplate = `
# This is a Terragrunt module generated by boilerplate.
terraform {
  source = "{{ .sourceUrl }}"
}

inputs = {
  # --------------------------------------------------------------------------------------------------------------------
  # Required input variables
  # --------------------------------------------------------------------------------------------------------------------
  {{ range .requiredVariables }}
  # Description: {{ .Description }}
  # Type: {{ .Type }}
  {{ .Name }} = {{ .DefaultValuePlaceholder }}  # TODO: fill in value
  {{ end }}

  # --------------------------------------------------------------------------------------------------------------------
  # Optional input variables
  # Uncomment the ones you wish to set
  # --------------------------------------------------------------------------------------------------------------------
  {{ range .optionalVariables }}
  # Description: {{ .Description }}
  # Type: {{ .Type }}
  # {{ .Name }} = {{ .DefaultValue }}
  {{ end }}
}
`
)

func Run(opts *options.TerragruntOptions) error {
	// download remote repo to local
	var moduleUrl = ""
	var templateUrl = ""
	// clean all temp dirs
	var dirsToClean []string
	defer func() {
		for _, dir := range dirsToClean {
			if err := os.RemoveAll(dir); err != nil {
				opts.Logger.Warnf("Failed to clean up dir %s: %v", dir, err)
			}
		}
	}()
	if len(opts.TerraformCliArgs) >= 2 {
		moduleUrl = opts.TerraformCliArgs[1]
	}

	if len(opts.TerraformCliArgs) >= 3 {
		templateUrl = opts.TerraformCliArgs[2]
	}

	tempDir, err := os.MkdirTemp("", "scaffold")
	if err != nil {
		return errors.WithStackTrace(err)
	}
	dirsToClean = append(dirsToClean, tempDir)

	// prepare inputs
	vars, err := variables.ParseVars(opts.ScaffoldVars, opts.ScaffoldVarFiles)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	// prepare source url

	parsedModuleUrl, err := terraform.ToSourceUrl(moduleUrl, tempDir)
	if err != nil {
		return errors.WithStackTrace(err)
	}
	moduleUrl = parsedModuleUrl.String()

	sourceUrlType := SourceUrlTypeHttps
	if value, found := vars["SourceUrlType"]; found {
		sourceUrlType = fmt.Sprintf("%s", value)
	}

	// rewrite module url
	scheme, host, path := parseUrl(opts, moduleUrl)
	// try to rewrite module url if is https and is requested to be git
	if scheme == "https" && sourceUrlType == SourceUrlTypeGit {
		gitUser := SourceGitSshUser
		if value, found := vars["SourceGitSshUser"]; found {
			gitUser = fmt.Sprintf("%s", value)
		}
		if strings.HasPrefix(path, "/") {
			path = path[1:]
		}
		moduleUrl = fmt.Sprintf("%s@%s:%s", gitUser, host, path)
	}

	// parse module url
	parsedModuleUrl, err = terraform.ToSourceUrl(moduleUrl, tempDir)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	// append ref to source url, if is passed through variables or find it from git tags
	params := parsedModuleUrl.Query()
	refReplacement, refVarPassed := vars["Ref"]
	if refVarPassed {
		params.Set("ref", fmt.Sprintf("%s", refReplacement))
		parsedModuleUrl.RawQuery = params.Encode()
	}
	ref := params.Get("ref")
	if ref == "" {
		// if ref is not passed, find last release tag
		rootSourceUrl, _, err := terraform.SplitSourceUrl(parsedModuleUrl, opts.Logger)
		if err != nil {
			return errors.WithStackTrace(err)
		}

		tag, err := shell.GitLastReleaseTag(opts, rootSourceUrl)
		if err != nil || tag == "" {
			opts.Logger.Warnf("Failed to find last release tag for %s", rootSourceUrl)
		} else {
			params.Add("ref", tag)
			parsedModuleUrl.RawQuery = params.Encode()
		}
	}

	// regenerate module url with all changes
	moduleUrl = parsedModuleUrl.String()

	// identify template url
	templateDir := ""
	if templateUrl != "" {
		parsedTemplateUrl, err := terraform.ToSourceUrl(templateUrl, tempDir)
		if err != nil {
			return errors.WithStackTrace(err)
		}

		var templateParams = parsedTemplateUrl.Query()
		ref := templateParams.Get("ref")
		if ref == "" {
			rootSourceUrl, _, err := terraform.SplitSourceUrl(parsedTemplateUrl, opts.Logger)
			if err != nil {
				return errors.WithStackTrace(err)
			}
			tag, err := shell.GitLastReleaseTag(opts, rootSourceUrl)
			if err != nil || tag == "" {
				opts.Logger.Warnf("Failed to find last release tag templae %s", rootSourceUrl)
			} else {
				templateParams.Add("ref", tag)
				parsedTemplateUrl.RawQuery = templateParams.Encode()
			}
		}

		templateDir, err = os.MkdirTemp("", "template")
		if err != nil {
			return errors.WithStackTrace(err)
		}
		dirsToClean = append(dirsToClean, templateDir)
		opts.Logger.Infof("Using template from %s as boilerplate", parsedTemplateUrl.String())

		if err := getter.GetAny(templateDir, parsedTemplateUrl.String()); err != nil {
			return errors.WithStackTrace(err)
		}
	}

	opts.Logger.Infof("Scaffolding a new Terragrunt module %s %s to %s", moduleUrl, templateUrl, opts.WorkingDir)
	if err := getter.GetAny(tempDir, parsedModuleUrl.String()); err != nil {
		return errors.WithStackTrace(err)
	}

	// extract variables
	inputs, err := config.ParseVariables(opts, tempDir)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	// separate inputs that require value and with default value
	var requiredVariables []*config.ParsedVariable
	var optionalVariables []*config.ParsedVariable

	for _, value := range inputs {
		if value.DefaultValue == "" {
			requiredVariables = append(requiredVariables, value)
		} else {
			optionalVariables = append(optionalVariables, value)
		}
	}
	opts.Logger.Debugf("Parsed %d required variables and %d optional variables", len(requiredVariables), len(optionalVariables))

	// run boilerplate

	// prepare boilerplate dir
	boilerplateDir := util.JoinPath(tempDir, util.DefaultBoilerplateDir)
	// use template dir as boilerplate dir
	if templateDir != "" {
		boilerplateDir = templateDir
	}

	// if boilerplate dir is not found, create one with default template
	if !files.IsExistingDir(boilerplateDir) {
		// no default boilerplate dir, create one
		boilerplateDir, err = os.MkdirTemp("", "boilerplate")
		if err != nil {
			return errors.WithStackTrace(err)
		}
		dirsToClean = append(dirsToClean, boilerplateDir)
		if err := os.WriteFile(util.JoinPath(boilerplateDir, "terragrunt.hcl"), []byte(defaultTerragruntTemplate), 0644); err != nil {
			return errors.WithStackTrace(err)
		}
		if err := os.WriteFile(util.JoinPath(boilerplateDir, "boilerplate.yml"), []byte(defaultBoilerplateConfig), 0644); err != nil {
			return errors.WithStackTrace(err)
		}
	}

	// add additional variables
	vars["requiredVariables"] = requiredVariables
	vars["optionalVariables"] = optionalVariables

	vars["sourceUrl"] = moduleUrl

	opts.Logger.Infof("Running boilerplate generation to %s", opts.WorkingDir)
	boilerplateOpts := &boilerplate_options.BoilerplateOptions{
		TemplateFolder:  boilerplateDir,
		OutputFolder:    opts.WorkingDir,
		OnMissingKey:    boilerplate_options.DefaultMissingKeyAction,
		OnMissingConfig: boilerplate_options.DefaultMissingConfigAction,
		Vars:            vars,

		NonInteractive: true,
	}
	emptyDep := variables.Dependency{}
	if err := templates.ProcessTemplate(boilerplateOpts, boilerplateOpts, emptyDep); err != nil {
		return errors.WithStackTrace(err)
	}

	opts.Logger.Infof("Running fmt on generated code %s", opts.WorkingDir)
	if err := hclfmt.Run(opts); err != nil {
		return errors.WithStackTrace(err)
	}
	return nil
}

func parseUrl(opts *options.TerragruntOptions, moduleUrl string) (string, string, string) {
	pattern := `git::([^:]+)://([^/]+)(/.*)`

	re := regexp.MustCompile(pattern)

	matches := re.FindStringSubmatch(moduleUrl)
	if len(matches) != 4 {
		opts.Logger.Warnf("Failed to parse module url %s", moduleUrl)
		return "", "", ""
	}

	scheme := matches[1]
	host := matches[2]
	path := matches[3]

	return scheme, host, path
}
