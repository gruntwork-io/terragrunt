---
title: State Backend
description: Learn how Terragrunt can create and manage remote state backends.
slug: docs/features/state-backend
sidebar:
  order: 4
---

import { FileTree } from '@astrojs/starlight/components';

## Motivation

OpenTofu/Terraform supports [remote state storage](https://www.terraform.io/docs/state/remote.html) via various [backends](https://www.terraform.io/docs/backends) that you normally configure in your `.tf` files as follows:

```hcl
# main.tf
terraform {
  backend "s3" {
    bucket         = "my-tofu-state"
    key            = "frontend-app/tofu.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "my-lock-table"
  }
}
```

Unfortunately, the `backend` configuration does not currently support expressions, variables, or functions. This makes it hard to keep your code [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) if you have multiple OpenTofu/Terraform modules. For example, consider the following folder structure, which uses different OpenTofu/Terraform modules to deploy a backend app, frontend app, MySQL database, and a VPC:

<FileTree>

- backend-app
  - main.tf
- frontend-app
  - main.tf
- mysql
  - main.tf
- vpc
  - main.tf

</FileTree>

To use remote state with each of these modules, you would have to copy/paste the identical `backend` configuration into each of the `main.tf` files. The only thing that would differ between the configurations would be the `key` parameter: e.g., the `key` for `mysql/main.tf` might be `mysql/terraform.tfstate` and the `key` for `frontend-app/main.tf` might be `frontend-app/terraform.tfstate`.

In addition, the resources used for remote state will be provisioned _somewhere else_, and that _somewhere else_ needs to be managed. Most users end up using "click-ops" to provision the S3 bucket and DynamoDB table used for AWS remote state (clicking around in the AWS console until they have what they need). This is error-prone, difficult to reproduce, and makes it hard to do the _right thing_ consistently (e.g., enabling versioning, encryption, and access logging).

Luckily, Terragrunt has built-in tooling to make it easy to manage remote state.

## Generating remote state settings with Terragrunt

To fill in the settings via Terragrunt, create a `root.hcl` file in the root folder, plus one `terragrunt.hcl` file in each of the OpenTofu/Terraform modules:

<FileTree>

- root.hcl
- backend-app
  - main.tf
  - terragrunt.hcl
- frontend-app
  - main.tf
  - terragrunt.hcl
- mysql
  - main.tf
  - terragrunt.hcl
- vpc
  - main.tf
  - terragrunt.hcl

</FileTree>

In your `root.hcl` file, you can define your entire remote state configuration just once in a `generate` block, to generate a `backend.tf` file that includes the backend configuration:

```hcl
# root.hcl
generate "backend" {
  path      = "backend.tf"
  if_exists = "overwrite_terragrunt"
  contents = <<EOF
terraform {
  backend "s3" {
    bucket         = "my-tofu-state"
    key            = "${path_relative_to_include()}/tofu.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "my-lock-table"
  }
}
EOF
}
```

This instructs Terragrunt to create the file `backend.tf` in the working directory (where Terragrunt calls `tofu`/`terraform`)
before it runs any OpenTofu/Terraform commands, including `init`. This allows you to inject this backend configuration
in all the units that include the root file and have `terragrunt` properly initialize the backend configuration with
interpolated values.

To inherit this configuration in each unit, such as `mysql/terragrunt.hcl`, you can
tell Terragrunt to automatically include all the settings from the root `root.hcl` file as follows:

```hcl
# mysql/terragrunt.hcl
include "root" {
  path = find_in_parent_folders("root.hcl")
}
```

The `include` block tells Terragrunt to use an identical Terragrunt configuration from the `root.hcl` file specified via the `path` parameter. It behaves exactly as if you had copy/pasted the OpenTofu/Terraform configuration from the included file `generate` configuration into `mysql/terragrunt.hcl`, but this approach is much easier to maintain\!

The next time you run `terragrunt`, it will automatically configure all the settings for the backend, if they aren’t configured already, by calling [tofu/terraform init](https://opentofu.org/docs/cli/commands/init/).

The `terragrunt.hcl` files above use two Terragrunt built-in functions:

- `find_in_parent_folders()`: This function returns the absolute path to the first file it finds in the parent folders above the current unit named something. In the example above, the call to `find_in_parent_folders("root.hcl")` in `mysql/terragrunt.hcl` will return `/your-root-folder/root.hcl`. This way, you don’t have to hard code the `path` parameter in every unit.

- `path_relative_to_include()`: This function returns the relative path between the unit and the path specified in its `include` block. We typically use this in a root `root.hcl` file so that each unit stores its OpenTofu/Terraform state at a different `key`. For example, the `mysql` unit will have its `key` parameter resolve to `mysql/tofu.tfstate` and the `frontend-app` module will have its `key` parameter resolve to `frontend-app/tofu.tfstate`.

Read [Functions docs](/docs/reference/hcl/functions) for more info.

## Create remote state resources automatically

The `generate` block is useful for allowing you to set up the remote state backend configuration automatically, but
this introduces a bootstrapping problem: how do you create and manage the underlying storage resources for the remote
state? For example, when using the [s3 backend](https://opentofu.org/docs/language/settings/backends/s3/), OpenTofu/Terraform
expects the S3 bucket to already exist for it to upload the state objects.

Ideally, you can manage the S3 bucket using OpenTofu/Terraform, but what about the state object for the module managing the S3
bucket? How do you create the S3 bucket, before you run `tofu`/`terraform`, if you need to run `tofu`/`terraform` to create the
bucket?

To handle this, Terragrunt supports a different block for managing the backend configuration: the [remote_state
block](/docs/reference/hcl/blocks/#remote_state).

> **NOTE**
>
> `remote_state` is an alternative way of managing the OpenTofu/Terraform backend compared to `generate`. You cannot use both
> methods at the same time to manage the remote state configuration. When implementing `remote_state`, be sure to remove
> the corresponding `generate` block for managing the backend.

The following backends are currently supported by `remote_state`:

- [s3 backend](https://opentofu.org/docs/language/settings/backends/s3)
- [gcs backend](https://opentofu.org/docs/language/settings/backends/gcs)
- [azurerm backend](https://opentofu.org/docs/language/settings/backends/azurerm)

For all other backends, the `remote_state` block operates in the same manner as `generate`. However, we may add
support for additional backends to `remote_state` blocks, which may disrupt your environment. If you do not want support
for automated management of remote state resources, we recommend sticking to `generate` blocks to configure the backend.

When you run `terragrunt` with a `remote_state` configuration, it will automatically create the following resources if they don’t already exist:

- **S3 bucket**: If you are using the [S3 backend](https://opentofu.org/docs/language/settings/backends/s3) for remote state storage and the `bucket` you specify in `remote_state.config` doesn’t already exist, Terragrunt will create it automatically, with [versioning](https://docs.aws.amazon.com/AmazonS3/latest/dev/Versioning.html), [server-side encryption](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html), and [access logging](https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerLogs.html) enabled.

  In addition, you can let terragrunt tag the bucket with custom tags that you specify in `remote_state.config.s3_bucket_tags`.

- **DynamoDB table**: If you are using the [S3 backend](https://opentofu.org/docs/language/settings/backends/s3) for remote state storage and/or you specify a `dynamodb_table` (a [DynamoDB table used for locking](https://opentofu.org/docs/language/settings/backends/s3/#dynamodb-state-locking)) in `remote_state.config`, Terragrunt will create them automatically if they don't already exist. They will be created with [server-side encryption](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/EncryptionAtRest.html) enabled, and the DynamoDB table will use the primary key `LockID`.

  You may configure a custom endpoint for the AWS DynamoDB API using `remote_state.config.dynamodb_endpoint`.

  In addition, you can let terragrunt tag the DynamoDB table with custom tags that you specify in `remote_state.config.dynamodb_table_tags`.

- **GCS bucket**: If you are using the [GCS backend](https://opentofu.org/docs/language/settings/backends/gcs) for remote state storage and the `bucket` you specify in `remote_state.config` doesn’t already exist, Terragrunt will create it automatically, with [versioning](https://cloud.google.com/storage/docs/object-versioning) enabled. For this to work correctly you must also specify `project` and `location` keys in `remote_state.config`, so Terragrunt knows where to create the bucket. You will also need to supply valid credentials using either `remote_state.config.credentials` or by setting the `GOOGLE_APPLICATION_CREDENTIALS` environment variable. If you want to skip creating the bucket entirely, simply set `skip_bucket_creation` to `true` and Terragrunt will assume the bucket has already been created. If you don’t specify `bucket` in `remote_state` then terragrunt will assume that you will pass `bucket` through `-backend-config` in `extra_arguments`.

  We also strongly recommend you enable [Cloud Audit Logs](https://cloud.google.com/storage/docs/access-logs) to audit and track API operations performed against the state bucket.

  In addition, you can let Terragrunt label the bucket with custom labels that you specify in `remote_state.config.gcs_bucket_labels`.

- **Azure Storage container**: If you are using the [Azure Storage backend](https://opentofu.org/docs/language/settings/backends/azurerm) for remote state storage and the `container_name` you specify in `remote_state.config` doesn't already exist, Terragrunt will create it automatically. The container will be created with:
  - [Blob versioning](https://learn.microsoft.com/en-us/azure/storage/blobs/versioning-overview) enabled at the storage account level (if supported)
  - Server-side encryption using Azure Storage encryption
  - Container level access policies configured for secure access

  You will need to specify `storage_account_name` and authentication credentials in `remote_state.config`. Authentication can be provided through (in order of recommended security practices):
  
  1. Azure AD credentials (automatically used if no other auth method is specified)
     - Supports Managed Identity, Service Principal, and User credentials
     - Most secure option with full audit trail and access control
     - Supports conditional access and MFA policies
  
  2. SAS token via `sas_token`
     - Good for limited-time access
     - Can be scoped to specific permissions
     - Must be regenerated when expired
  
  3. Storage account key via `storage_account_key`
     - Provides full access to the storage account
     - Should only be used when Azure AD authentication is not possible
     - Recommended to rotate keys regularly

  Best practices:
  - Enable [Azure Storage logging and metrics](https://learn.microsoft.com/en-us/azure/storage/common/storage-analytics-logging) for audit and operations tracking
  - Use Azure AD authentication when possible
  - Enable [soft delete for blobs](https://learn.microsoft.com/en-us/azure/storage/blobs/soft-delete-blob-overview) on the storage account
  - Set up [Azure Monitor alerts](https://learn.microsoft.com/en-us/azure/storage/blobs/monitor-blob-storage) for unauthorized access attempts
  - Consider using [Azure Private Endpoints](https://learn.microsoft.com/en-us/azure/private-link/private-endpoint-overview) for secure network access

**Note**: If you specify a `profile` key in `remote_state.config`, Terragrunt will automatically use this AWS profile when creating the S3 bucket or DynamoDB table.

**Note**: You can disable automatic remote state initialization by setting `remote_state.disable_init`, this will skip the automatic creation of remote state resources and will execute `terraform init` passing the `backend=false` option. This can be handy when running commands such as `run --all validate` as part of a CI process where you do not want to initialize remote state.

The following example demonstrates using an environment variable to configure this option:

```hcl
# root.hcl
remote_state {
  # ...

  disable_init = tobool(get_env("TG_DISABLE_INIT", "false"))
}
```

Here is an example of using the `remote_state` block to configure the S3 backend:

```hcl
# S3 Backend Example
remote_state {
  backend = "s3"
  generate = {
    path      = "backend.tf"
    if_exists = "overwrite"
  }
  config = {
    bucket         = "my-terraform-state"
    key            = "${path_relative_to_include()}/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "my-lock-table"
  }
}

# Azure Storage Backend Example
remote_state {
  backend = "azurerm"
  generate = {
    path      = "backend.tf"
    if_exists = "overwrite"
  }
  config = {
    # Required settings
    storage_account_name = "mystorageaccount"
    container_name      = "terraform-state"
    key                = "${path_relative_to_include()}/terraform.tfstate"
    
    # Optional: Use Azure region different from the storage account's location
    resource_group_name = "my-terraform-state-rg"    # If storage account is in a different resource group
    subscription_id    = "00000000-0000-0000-0000-000000000000"  # If storage account is in a different subscription

    # Authentication Methods (choose one):
    
    # 1. Azure AD Authentication (recommended)
    use_azuread_auth   = true    # Optional, defaults to true if no other auth method specified
    # Supports Managed Identity, Service Principal, and az cli credentials automatically
    
    # 2. SAS Token Authentication
    # sas_token         = "your-sas-token"
    # use_azuread_auth  = false
    
    # 3. Storage Account Key Authentication (least recommended)
    # storage_account_key = "your-storage-account-key"
    # use_azuread_auth   = false
    
    # Optional: Disable Terragrunt's automatic container management
    disable_container_update = true  # Set to true if you want to manage container settings manually
  }
}
```

Like the approach with `generate` blocks, this will generate a `backend.tf` file that contains the remote state
configuration. However, in addition to that, `terragrunt` will also now manage the S3 bucket and DynamoDB table for you.
This means that if the S3 bucket `my-terraform-state` and DynamoDB table `my-lock-table` does not exist in your account,
Terragrunt will automatically create these resources before calling `terraform` and configure them based on the
specified configuration parameters.

Additionally, for **the S3 backend only**, Terragrunt will automatically update the S3 resource to match the
configuration specified in the `remote_state` bucket. For example, if you require versioning in the `remote_state`
block, but the underlying state bucket doesn't have versioning enabled, Terragrunt will automatically turn on versioning
on the bucket to match the configuration.

If you do not want `terragrunt` to automatically apply changes, you can configure the following:

```hcl
# root.hcl
remote_state {
  # ... other args omitted for brevity ...
  config = {
    # ... other config omitted for brevity ...
    disable_bucket_update = true
  }
}
```

Check out the [terragrunt-infrastructure-modules-example](https://github.com/gruntwork-io/terragrunt-infrastructure-modules-example) and [terragrunt-infrastructure-live-example](https://github.com/gruntwork-io/terragrunt-infrastructure-live-example) repos for fully-working sample code that demonstrates how to use Terragrunt to manage remote state.

## Azure-specific remote state settings

For the `azurerm` backend, Terragrunt will automatically create the following resources if they don't exist:

- **Azure Storage Container**: If you are using the [Azure Storage backend](https://learn.microsoft.com/en-us/azure/developer/terraform/store-state-in-azure-storage?tabs=azure-cli) for remote state storage and the container you specify in `remote_state.config` doesn't exist, Terragrunt will create it automatically.

Here's an example of using the `remote_state` block to configure the Azure Storage backend:

```hcl
remote_state {
  backend = "azurerm"
  generate = {
    path      = "backend.tf"
    if_exists = "overwrite"
  }
  config = {
    storage_account_name = "mystorageaccount"
    container_name      = "terraform-state"
    key                = "${path_relative_to_include()}/terraform.tfstate"
    use_azuread_auth   = true   # Use Azure AD authentication (recommended)
  }
}
```

### Azure Authentication Methods

The Azure backend supports multiple authentication methods:

1. **Azure AD Authentication** (recommended) - Set `use_azuread_auth = true`
2. **Storage Account Key** - Provide via `access_key`
3. **SAS Token** - Provide via `sas_token`

### Important Notes

1. **Versioning**: In Azure Storage, blob versioning is a storage account level setting and cannot be configured at the container level.
2. **Server-Side Encryption**: Azure Storage automatically encrypts all data at rest.
3. **Authentication**: Azure AD authentication is recommended over access keys or SAS tokens for better security.
4. **Locking**: Azure Blob lease is used for state locking, no additional resources needed.

### Error Messages

Common error messages and their resolutions:

| Error Message | Resolution |
|--------------|------------|
| `container name is required` | Specify a valid container name in config |
| `authentication failed` | Check Azure credentials and permissions |
| `error checking container existence` | Verify network connectivity and access |
| `blob not found` | Verify state file path and container name |

### Best Practices

1. Use Azure AD authentication by setting `use_azuread_auth = true`
2. Enable blob versioning at the storage account level
3. Use separate containers for different environments
4. Use descriptive paths in the `key` parameter
