---
title: State Backend
description: Learn how Terragrunt can create and manage remote state backends.
slug: docs/features/state-backend
sidebar:
  order: 4
---

import { FileTree } from '@astrojs/starlight/components';

## Motivation

OpenTofu/Terraform supports [remote state storage](https://www.terraform.io/docs/state/remote.html) via various [backends](https://www.terraform.io/docs/backends) that you normally configure in your `.tf` files as follows:

```hcl
# main.tf
terraform {
  backend "s3" {
    bucket         = "my-tofu-state"
    key            = "frontend-app/tofu.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "my-lock-table"
  }
}
```

Unfortunately, the `backend` configuration does not currently support expressions, variables, or functions. This makes it hard to keep your code [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) if you have multiple OpenTofu/Terraform modules. For example, consider the following folder structure, which uses different OpenTofu/Terraform modules to deploy a backend app, frontend app, MySQL database, and a VPC:

<FileTree>

- backend-app
  - main.tf
- frontend-app
  - main.tf
- mysql
  - main.tf
- vpc
  - main.tf

</FileTree>

To use remote state with each of these modules, you would have to copy/paste the identical `backend` configuration into each of the `main.tf` files. The only thing that would differ between the configurations would be the `key` parameter: e.g., the `key` for `mysql/main.tf` might be `mysql/terraform.tfstate` and the `key` for `frontend-app/main.tf` might be `frontend-app/terraform.tfstate`.

In addition, the resources used for remote state will be provisioned _somewhere else_, and that _somewhere else_ needs to be managed. Most users end up using "click-ops" to provision the S3 bucket and DynamoDB table used for AWS remote state (clicking around in the AWS console until they have what they need). This is error-prone, difficult to reproduce, and makes it hard to do the _right thing_ consistently (e.g., enabling versioning, encryption, and access logging).

Luckily, Terragrunt has built-in tooling to make it easy to manage remote state.

## Generating remote state settings with Terragrunt

To fill in the settings via Terragrunt, create a `root.hcl` file in the root folder, plus one `terragrunt.hcl` file in each of the OpenTofu/Terraform modules:

<FileTree>

- root.hcl
- backend-app
  - main.tf
  - terragrunt.hcl
- frontend-app
  - main.tf
  - terragrunt.hcl
- mysql
  - main.tf
  - terragrunt.hcl
- vpc
  - main.tf
  - terragrunt.hcl

</FileTree>

In your `root.hcl` file, you can define your entire remote state configuration just once in a `generate` block, to generate a `backend.tf` file that includes the backend configuration:

```hcl
# root.hcl
generate "backend" {
  path      = "backend.tf"
  if_exists = "overwrite_terragrunt"
  contents = <<EOF
terraform {
  backend "s3" {
    bucket         = "my-tofu-state"
    key            = "${path_relative_to_include()}/tofu.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "my-lock-table"
  }
}
EOF
}
```

This instructs Terragrunt to create the file `backend.tf` in the working directory (where Terragrunt calls `tofu`/`terraform`)
before it runs any OpenTofu/Terraform commands, including `init`. This allows you to inject this backend configuration
in all the units that include the root file and have `terragrunt` properly initialize the backend configuration with
interpolated values.

To inherit this configuration in each unit, such as `mysql/terragrunt.hcl`, you can
tell Terragrunt to automatically include all the settings from the root `root.hcl` file as follows:

```hcl
# mysql/terragrunt.hcl
include "root" {
  path = find_in_parent_folders("root.hcl")
}
```

The `include` block tells Terragrunt to use an identical Terragrunt configuration from the `root.hcl` file specified via the `path` parameter. It behaves exactly as if you had copy/pasted the OpenTofu/Terraform configuration from the included file `generate` configuration into `mysql/terragrunt.hcl`, but this approach is much easier to maintain\!

The next time you run `terragrunt`, it will automatically configure all the settings for the backend, if they aren’t configured already, by calling [tofu/terraform init](https://opentofu.org/docs/cli/commands/init/).

The `terragrunt.hcl` files above use two Terragrunt built-in functions:

- `find_in_parent_folders()`: This function returns the absolute path to the first file it finds in the parent folders above the current unit named something. In the example above, the call to `find_in_parent_folders("root.hcl")` in `mysql/terragrunt.hcl` will return `/your-root-folder/root.hcl`. This way, you don’t have to hard code the `path` parameter in every unit.

- `path_relative_to_include()`: This function returns the relative path between the unit and the path specified in its `include` block. We typically use this in a root `root.hcl` file so that each unit stores its OpenTofu/Terraform state at a different `key`. For example, the `mysql` unit will have its `key` parameter resolve to `mysql/tofu.tfstate` and the `frontend-app` module will have its `key` parameter resolve to `frontend-app/tofu.tfstate`.

Read [Functions docs](/docs/reference/hcl/functions) for more info.

## Create remote state resources automatically

The `generate` block is useful for allowing you to set up the remote state backend configuration automatically, but
this introduces a bootstrapping problem: how do you create and manage the underlying storage resources for the remote
state? For example, when using the [s3 backend](https://opentofu.org/docs/language/settings/backends/s3/), OpenTofu/Terraform
expects the S3 bucket to already exist for it to upload the state objects.

Ideally, you can manage the S3 bucket using OpenTofu/Terraform, but what about the state object for the module managing the S3
bucket? How do you create the S3 bucket, before you run `tofu`/`terraform`, if you need to run `tofu`/`terraform` to create the
bucket?

To handle this, Terragrunt supports a different block for managing the backend configuration: the [remote_state
block](/docs/reference/hcl/blocks/#remote_state).

> **NOTE**
>
> `remote_state` is an alternative way of managing the OpenTofu/Terraform backend compared to `generate`. You cannot use both
> methods at the same time to manage the remote state configuration. When implementing `remote_state`, be sure to remove
> the corresponding `generate` block for managing the backend.

The following backends are currently supported by `remote_state`:

- [s3 backend](https://opentofu.org/docs/language/settings/backends/s3)
- [gcs backend](https://opentofu.org/docs/language/settings/backends/gcs)
- [azurerm backend](https://opentofu.org/docs/language/settings/backends/azurerm)

For all other backends, the `remote_state` block operates in the same manner as `generate`. However, we may add
support for additional backends to `remote_state` blocks, which may disrupt your environment. If you do not want support
for automated management of remote state resources, we recommend sticking to `generate` blocks to configure the backend.

When you run `terragrunt` with a `remote_state` configuration, it will automatically create the following resources if they don’t already exist:

- **S3 bucket**: If you are using the [S3 backend](https://opentofu.org/docs/language/settings/backends/s3) for remote state storage and the `bucket` you specify in `remote_state.config` doesn’t already exist, Terragrunt will create it automatically, with [versioning](https://docs.aws.amazon.com/AmazonS3/latest/dev/Versioning.html), [server-side encryption](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html), and [access logging](https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerLogs.html) enabled.

  In addition, you can let terragrunt tag the bucket with custom tags that you specify in `remote_state.config.s3_bucket_tags`.

- **DynamoDB table**: If you are using the [S3 backend](https://opentofu.org/docs/language/settings/backends/s3) for remote state storage and/or you specify a `dynamodb_table` (a [DynamoDB table used for locking](https://opentofu.org/docs/language/settings/backends/s3/#dynamodb-state-locking)) in `remote_state.config`, Terragrunt will create them automatically if they don't already exist. They will be created with [server-side encryption](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/EncryptionAtRest.html) enabled, and the DynamoDB table will use the primary key `LockID`.

  You may configure a custom endpoint for the AWS DynamoDB API using `remote_state.config.dynamodb_endpoint`.

  In addition, you can let terragrunt tag the DynamoDB table with custom tags that you specify in `remote_state.config.dynamodb_table_tags`.

- **GCS bucket**: If you are using the [GCS backend](https://opentofu.org/docs/language/settings/backends/gcs) for remote state storage and the `bucket` you specify in `remote_state.config` doesn’t already exist, Terragrunt will create it automatically, with [versioning](https://cloud.google.com/storage/docs/object-versioning) enabled. For this to work correctly you must also specify `project` and `location` keys in `remote_state.config`, so Terragrunt knows where to create the bucket. You will also need to supply valid credentials using either `remote_state.config.credentials` or by setting the `GOOGLE_APPLICATION_CREDENTIALS` environment variable. If you want to skip creating the bucket entirely, simply set `skip_bucket_creation` to `true` and Terragrunt will assume the bucket has already been created. If you don’t specify `bucket` in `remote_state` then terragrunt will assume that you will pass `bucket` through `-backend-config` in `extra_arguments`.

  We also strongly recommend you enable [Cloud Audit Logs](https://cloud.google.com/storage/docs/access-logs) to audit and track API operations performed against the state bucket.

  In addition, you can let Terragrunt label the bucket with custom labels that you specify in `remote_state.config.gcs_bucket_labels`.

- **Azure Storage container**: If you are using the [Azure Storage backend](https://opentofu.org/docs/language/settings/backends/azurerm) for remote state storage and the `container_name` you specify in `remote_state.config` doesn't already exist, Terragrunt will create it automatically. The container will be created with:
  - [Blob versioning](https://learn.microsoft.com/en-us/azure/storage/blobs/versioning-overview) enabled at the storage account level (if supported)
  - Server-side encryption using Azure Storage encryption
  - Container level access policies configured for secure access

  You will need to specify `storage_account_name` and authentication credentials in `remote_state.config`. Authentication can be provided through (in order of recommended security practices):
  
  1. Azure AD credentials (automatically used if no other auth method is specified)
     - Supports Managed Identity, Service Principal, and User credentials
     - Most secure option with full audit trail and access control
     - Supports conditional access and MFA policies
  
  2. SAS token via `sas_token`
     - Good for limited-time access
     - Can be scoped to specific permissions
     - Must be regenerated when expired
  
  3. Storage account key via `storage_account_key`
     - Provides full access to the storage account
     - Should only be used when Azure AD authentication is not possible
     - Recommended to rotate keys regularly

  Best practices:
  - Enable [Azure Storage logging and metrics](https://learn.microsoft.com/en-us/azure/storage/common/storage-analytics-logging) for audit and operations tracking
  - Use Azure AD authentication when possible
  - Enable [soft delete for blobs](https://learn.microsoft.com/en-us/azure/storage/blobs/soft-delete-blob-overview) on the storage account
  - Set up [Azure Monitor alerts](https://learn.microsoft.com/en-us/azure/storage/blobs/monitor-blob-storage) for unauthorized access attempts
  - Consider using [Azure Private Endpoints](https://learn.microsoft.com/en-us/azure/private-link/private-endpoint-overview) for secure network access

**Note**: If you specify a `profile` key in `remote_state.config`, Terragrunt will automatically use this AWS profile when creating the S3 bucket or DynamoDB table.

**Note**: You can disable automatic remote state initialization by setting `remote_state.disable_init`, this will skip the automatic creation of remote state resources and will execute `terraform init` passing the `backend=false` option. This can be handy when running commands such as `run --all validate` as part of a CI process where you do not want to initialize remote state.

The following example demonstrates using an environment variable to configure this option:

```hcl
# root.hcl
remote_state {
  # ...

  disable_init = tobool(get_env("TG_DISABLE_INIT", "false"))
}
```

Here is an example of using the `remote_state` block to configure the S3 backend:

```hcl
# S3 Backend Example
remote_state {
  backend = "s3"
  generate = {
    path      = "backend.tf"
    if_exists = "overwrite"
  }
  config = {
    bucket         = "my-terraform-state"
    key            = "${path_relative_to_include()}/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "my-lock-table"
  }
}

# Azure Storage Backend Example
remote_state {
  backend = "azurerm"
  generate = {
    path      = "backend.tf"
    if_exists = "overwrite"
  }
  config = {
    # Required settings
    storage_account_name = "mystorageaccount"
    container_name      = "terraform-state"
    key                = "${path_relative_to_include()}/terraform.tfstate"
    
    # Optional: Use Azure region different from the storage account's location
    resource_group_name = "my-terraform-state-rg"    # If storage account is in a different resource group
    subscription_id    = "00000000-0000-0000-0000-000000000000"  # If storage account is in a different subscription

    # Authentication Methods (choose one):
    
    # 1. Azure AD Authentication (recommended)
    use_azuread_auth   = true    # Optional, defaults to true if no other auth method specified
    # Supports Managed Identity, Service Principal, and az cli credentials automatically
    
    # 2. SAS Token Authentication
    # sas_token         = "your-sas-token"
    # use_azuread_auth  = false
    
    # 3. Storage Account Key Authentication (least recommended)
    # storage_account_key = "your-storage-account-key"
    # use_azuread_auth   = false
    
    # Optional: Disable Terragrunt's automatic container management
    disable_container_update = true  # Set to true if you want to manage container settings manually
  }
}
```

Like the approach with `generate` blocks, this will generate a `backend.tf` file that contains the remote state
configuration. However, in addition to that, `terragrunt` will also now manage the S3 bucket and DynamoDB table for you.
This means that if the S3 bucket `my-terraform-state` and DynamoDB table `my-lock-table` does not exist in your account,
Terragrunt will automatically create these resources before calling `terraform` and configure them based on the
specified configuration parameters.

Additionally, for **the S3 backend only**, Terragrunt will automatically update the S3 resource to match the
configuration specified in the `remote_state` bucket. For example, if you require versioning in the `remote_state`
block, but the underlying state bucket doesn't have versioning enabled, Terragrunt will automatically turn on versioning
on the bucket to match the configuration.

If you do not want `terragrunt` to automatically apply changes, you can configure the following:

```hcl
# root.hcl
remote_state {
  # ... other args omitted for brevity ...
  config = {
    # ... other config omitted for brevity ...
    disable_bucket_update = true
  }
}
```

Check out the [terragrunt-infrastructure-modules-example](https://github.com/gruntwork-io/terragrunt-infrastructure-modules-example) and [terragrunt-infrastructure-live-example](https://github.com/gruntwork-io/terragrunt-infrastructure-live-example) repos for fully-working sample code that demonstrates how to use Terragrunt to manage remote state.

## Azure-specific remote state settings

For the `azurerm` backend, Terragrunt will automatically create and manage the following resources if they don't exist:

- **Azure Storage Account**: If you enable storage account bootstrap with `create_storage_account_if_not_exists = true`, Terragrunt will create the storage account if it doesn't exist, with secure defaults including:
  - [Blob versioning](https://learn.microsoft.com/en-us/azure/storage/blobs/versioning-overview) enabled
  - [Server-side encryption](https://learn.microsoft.com/en-us/azure/storage/common/storage-service-encryption) using Azure Storage encryption
  - Public access blocked by default
  - Appropriate RBAC permissions assigned

- **Azure Storage Container**: If the container specified in `container_name` doesn't exist, Terragrunt will create it automatically with appropriate access controls.

Here's an example of using the `remote_state` block to configure the Azure Storage backend:

```hcl
remote_state {
  backend = "azurerm"
  generate = {
    path      = "backend.tf"
    if_exists = "overwrite"
  }
  config = {
    # Required settings
    storage_account_name = "mystorageaccount"
    container_name      = "terraform-state"
    key                = "${path_relative_to_include()}/terraform.tfstate"
    
    # Storage account bootstrap settings (optional)
    create_storage_account_if_not_exists = true
    subscription_id     = "00000000-0000-0000-0000-000000000000"  # Required if creating storage account
    resource_group_name = "my-terraform-state-rg"
    location           = "eastus"
    
    # Storage account configuration (optional)
    enable_versioning   = true        # Default: true
    account_kind        = "StorageV2" # Default: StorageV2
    account_tier        = "Standard"  # Default: Standard
    replication_type    = "LRS"       # Default: LRS
    access_tier         = "Hot"       # Default: Hot
    
    # Tags for the storage account (optional)
    storage_account_tags = {
      Environment = "Production"
      ManagedBy   = "Terragrunt"
    }
  }
}
```

### Azure Authentication

Azure AD authentication is now the **only** supported authentication method in Terragrunt for Azure Storage backend. This aligns with security best practices and provides better access control and auditing capabilities.

The Azure Default Credential Chain is used, which tries multiple authentication methods in the following order:

1. Environment Variables (`AZURE_TENANT_ID`, `AZURE_CLIENT_ID`, `AZURE_CLIENT_SECRET`)
2. Managed Identity (when running in Azure)
3. Azure CLI credentials (when signed in with `az login`)
4. Visual Studio Code credentials (when signed in to Azure extension)

You can also explicitly configure authentication using:

```hcl
config = {
  use_azuread_auth = true    # Optional, defaults to true
  subscription_id  = "..."   # Required for storage account creation
  tenant_id       = "..."    # Optional
  client_id       = "..."    # Optional
  client_secret   = "..."    # Optional
  use_msi         = true     # Optional, for Managed Identity
}
```

### Important Notes

1. **Azure AD Only**: Storage account key and connection string authentication methods are no longer supported
2. **Versioning**: Blob versioning is managed at the storage account level and enabled by default during bootstrap
3. **Server-Side Encryption**: Azure Storage automatically encrypts all data at rest
4. **Access Control**: RBAC permissions are automatically assigned during bootstrap
5. **Locking**: Azure Blob lease is used for state locking, no additional resources needed
6. **Legacy Support**: If you see warnings about `ARM_ACCESS_KEY` or `AZURE_STORAGE_KEY` environment variables, update to Azure AD authentication

### Error Messages and Troubleshooting

Common error messages and their resolutions:

| Error Message | Resolution |
|--------------|------------|
| `subscription_id is required for storage account creation` | Add `subscription_id` to config when using `create_storage_account_if_not_exists = true` |
| `location is required for storage account creation` | Add `location` to config when using `create_storage_account_if_not_exists = true` |
| `container name is required` | Specify a valid container name in config |
| `authentication failed` | Check Azure AD credentials and permissions |
| `no valid authentication method found` | Configure Azure AD authentication method |
| `error checking container existence` | Verify network connectivity and access |
| `blob not found` | Verify state file path and container name |
| `ARM_ACCESS_KEY is no longer supported` | Switch to Azure AD authentication |
| `AZURE_STORAGE_KEY is no longer supported` | Switch to Azure AD authentication |

### Best Practices

1. **Authentication**
   - Use Azure AD authentication (now the default)
   - Use managed identities in Azure environments
   - Rotate service principal credentials regularly if used

2. **Storage Configuration**
   - Enable blob versioning at the storage account level (enabled by default during bootstrap)
   - Use ZRS or GRS replication for production environments
   - Consider using the Cool access tier for cost optimization

3. **Access Control**
   - Use separate containers for different environments
   - Apply resource locks to prevent accidental deletion
   - Use Azure Private Endpoints for secure network access
   - Enable Azure Defender for Storage

4. **Organization**
   - Use descriptive paths in the `key` parameter
   - Apply meaningful tags to storage accounts
   - Use consistent naming conventions

5. **Monitoring**
   - Enable Azure Monitor diagnostics
   - Set up alerts for unauthorized access attempts
   - Configure Activity Log alerts for critical operations

6. **Backup and Recovery**
   - Enable soft delete for blobs
   - Configure periodic backup policies
   - Test recovery procedures regularly

### Storage Account Bootstrap Process

When `create_storage_account_if_not_exists = true` is set, Terragrunt follows this process:

1. **Authentication Check**: Verifies Azure AD authentication is configured
2. **Subscription Access**: Validates access to the specified subscription
3. **Resource Group**: Uses the specified resource group or creates one with the pattern `{storage_account_name}-rg`
4. **Storage Account Creation**: If the storage account doesn't exist:
   - Creates it with the specified configuration
   - Enables versioning by default
   - Assigns RBAC permissions
   - Applies specified tags
5. **Container Management**: Creates the state container if it doesn't exist

Example configuration with storage account bootstrap:

```hcl
remote_state {
  backend = "azurerm"
  generate = {
    path      = "backend.tf"
    if_exists = "overwrite"
  }
  config = {
    # Required settings
    storage_account_name = "mystorageaccount"
    container_name      = "terraform-state"
    key                = "${path_relative_to_include()}/terraform.tfstate"
    subscription_id    = "00000000-0000-0000-0000-000000000000"
    
    # Storage account bootstrap parameters
    create_storage_account_if_not_exists = true
    resource_group_name = "my-terraform-rg"
    location            = "eastus"
    enable_versioning   = true
    allow_blob_public_access = false
    
    # Optional storage account configuration
    account_kind        = "StorageV2"  # Optional: StorageV2 (default), BlobStorage, BlockBlobStorage, FileStorage
    replication_type    = "LRS"        # Optional: LRS (default), GRS, RAGRS, ZRS, GZRS, RAGZRS
    access_tier         = "Hot"        # Optional: Hot (default), Cool, Premium
    storage_account_tags = {           # Optional: Tags to apply to the storage account
      Environment = "Production"
      Owner = "Terragrunt"
    }
  }
}
```

#### Storage Account Bootstrap Options

| Option | Description | Default |
|--------|-------------|---------|
| `create_storage_account_if_not_exists` | Whether to check if the storage account exists and create it if needed | `false` |
| `resource_group_name` | Resource group for the storage account | Same as storage account name with `-rg` suffix |
| `location` | Azure region where the storage account should be created | `eastus` |
| `enable_versioning` | Whether blob versioning should be enabled on the storage account | `true` |
| `allow_blob_public_access` | Whether the storage account should allow public blob access | `false` |
| `account_kind` | Storage account kind | `StorageV2` |
| `account_tier` | Storage account performance tier | `Standard` |
| `access_tier` | Access tier for the storage account | `Hot` |
| `replication_type` | Data replication type | `LRS` |
| `storage_account_tags` | Tags to apply to the storage account | `{ created-by = "terragrunt" }` |

#### Storage Account Bootstrap Requirements

For storage account bootstrap to work:

1. You must provide a valid `subscription_id` where you have permissions to create resources
2. Your authentication method must have permissions to create/modify storage accounts
3. The specified resource group must exist, or you must have permissions to create resource groups

If the storage account already exists, Terragrunt will check its configuration and update certain settings like versioning if they don't match what's specified in your configuration.

#### Managing Existing Storage Accounts

If you've already created your storage account manually but want Terragrunt to ensure it has proper settings:

```hcl
remote_state {
  backend = "azurerm"
  # ... other configuration ...
  config = {
    # ... standard backend configuration ...
    
    # Check and update existing storage account if necessary
    create_storage_account_if_not_exists = true
    enable_versioning = true
    allow_blob_public_access = false
    skip_storage_account_update = false  # By default, Terragrunt will update existing accounts
  }
}
```

To disable updating existing storage accounts, set `skip_storage_account_update = true`.

#### Azure Authentication

Starting from version X.X.X, Azure AD authentication is the only supported authentication method for Azure remote state backend. Storage account key authentication is no longer supported.

To use Azure AD authentication:

```hcl
remote_state {
  backend = "azurerm"
  # ... other configuration ...
  config = {
    # Required - defaults to true even if not specified
    use_azuread_auth = true  
    
    # Storage account configuration
    storage_account_name = "mystorageaccount"
    container_name = "terraform-state"
    key = "${path_relative_to_include()}/terraform.tfstate"
    
    # Optional - needed for certain Azure AD permission scenarios
    subscription_id = "00000000-0000-0000-0000-000000000000"
    tenant_id = "00000000-0000-0000-0000-000000000000"
  }
}
```

Azure AD authentication uses the [Azure Default Credential Chain](https://learn.microsoft.com/en-us/dotnet/api/azure.identity.defaultazurecredential), which tries multiple authentication methods in the following order:

1. **Environment variables** (AZURE_TENANT_ID, AZURE_CLIENT_ID, AZURE_CLIENT_SECRET)
2. **Managed Identity** (when running in Azure)
3. **Azure CLI credentials** (when signed in with `az login`)
4. **Visual Studio Code credentials** (when signed in to Azure extension)

For additional authentication options, you can use:

| Option | Description | 
|--------|-------------|
| `use_msi` | Use Managed Service Identity for authentication when running in Azure | 
| `client_id` | Service principal client ID for Azure AD auth | 
| `client_secret` | Service principal client secret for Azure AD auth |
| `tenant_id` | Azure AD tenant ID |
| `subscription_id` | Azure subscription ID (required for storage account bootstrap) |
| `sas_token` | SAS token for read/write access to storage account (not recommended for production) |

Deprecated authentication options that are no longer supported:

- `storage_account_key` - Removed in favor of Azure AD authentication
- `connection_string` - Removed in favor of Azure AD authentication
- Environment variables ARM_ACCESS_KEY and AZURE_STORAGE_KEY
