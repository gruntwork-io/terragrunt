---
title: Stacks
description: Recommended patterns for using Terragrunt Stacks in real-world repositories, including nested stacks, root generation boundaries, and the “all” stack pattern.
slug: docs/features/stacks
sidebar:
  order: 2
---

import FileTree from '@components/vendored/starlight/FileTree.astro';
import { Aside } from '@astrojs/starlight/components';

## What are Stacks?

A **stack** in Terragrunt is a collection of related units that can be generated and operated as a single boundary.

Stacks allow you to:

* Deploy multiple infrastructure components with a single command.
* Compose infrastructure declaratively.
* Control blast radius through the working directory.
* Separate reusable infrastructure patterns from environment instantiation.

Terragrunt supports two approaches:

1. **Implicit stacks** (directory-based).
2. **Explicit stacks** (`terragrunt.stack.hcl` blueprints).

For small repositories, implicit stacks are often sufficient.
For multi-environment, multi-account, or reusable infrastructure catalogs, explicit stacks are strongly recommended.

---

## Implicit Stacks

An implicit stack is simply a directory containing multiple `terragrunt.hcl` units.

<FileTree>

* live

  * dev

    * vpc

      * terragrunt.hcl
    * eks

      * terragrunt.hcl
    * rds

      * terragrunt.hcl

</FileTree>

From `live/dev`:

```bash
terragrunt run --all plan
terragrunt run --all apply
terragrunt run --all destroy
```

This model is simple and transparent. However, it becomes repetitive and harder to maintain when multiple environments share the same structure.

---

## Explicit Stacks

Explicit stacks are defined using `terragrunt.stack.hcl`. These files act as **blueprints** that generate units into a `.terragrunt-stack/` directory.

Typical workflow:

```bash
terragrunt stack generate
terragrunt stack run plan
terragrunt stack run apply
```

Generated files are written to:

```
.terragrunt-stack/
```

This directory is a generated artifact and should not be committed to version control.

Explicit stacks allow:

* Reusable environment blueprints.
* Clean separation between structure and execution.
* Centralized composition of infrastructure slices.

---

## Recommended Repository Pattern

The most maintainable structure separates:

* `live/` → environment manifests
* `catalog/` → reusable stacks
* `units/` → execution wiring (dependencies, backend, providers, inputs)

<FileTree>

* live

  * dev

    * terragrunt.stack.hcl
  * prod

    * terragrunt.stack.hcl
* catalog

  * stacks

    * env

      * terragrunt.stack.hcl
  * units

    * networking

      * vpc

        * terragrunt.hcl
    * platform

      * eks

        * terragrunt.hcl

</FileTree>

The `live/<env>` stack should be intentionally small and declarative.
The `catalog` defines reusable composition logic.
Units remain the only place where execution wiring (dependencies, remote state, providers) is defined.

---

## Nested Stacks

Stacks can contain other stacks. This enables layered composition:

* Root stack (environment boundary)
* Domain stacks (networking, security, platform, apps)
* Units

Nested stacks prevent monolithic blueprints and allow clear logical boundaries.

---

## Root Stack Recommendation (Generation Boundary)

If stacks depend on each other, define a **single root stack per generation boundary**.

Why this matters:

Terragrunt generates units under `.terragrunt-stack/` relative to where `stack generate` is executed.

If stacks are generated independently in separate directories, you end up with multiple generation trees:

```
networking/.terragrunt-stack/
platform/.terragrunt-stack/
```

Relative `config_path` references between stacks become fragile or impossible.

Instead, define one root stack that composes all dependent stacks:

<FileTree>

* live

  * dev

    * terragrunt.stack.hcl
    * .terragrunt-stack

      * networking
      * platform
      * apps

</FileTree>

All generated units now share the same root tree.
Relative paths between stacks are stable and predictable.

This root stack defines the **generation boundary**.

---

## The “All” Stack Pattern

In advanced setups, environments may need to reference each other intentionally (for example: migrations, shared bootstrap components, promotion workflows, controlled cutovers).

To support this reliably, define a single **“all” stack** that generates all environments under one `.terragrunt-stack/` tree.

### Layout

<FileTree>

* live

  * all

    * terragrunt.stack.hcl
* catalog

  * stacks

    * env

      * terragrunt.stack.hcl
  * units

    * networking

      * vpc

        * terragrunt.hcl
    * platform

      * eks

        * terragrunt.hcl

</FileTree>

### Root “all” stack

`live/all/terragrunt.stack.hcl`

```hcl
stack "dev" {
  source = "${get_repo_root()}/catalog/stacks/env"
  path   = "dev"

  values = {
    environment    = "dev"
    aws_account_id = "111111111111"
    aws_region     = "eu-west-1"
    cidr           = "10.20.0.0/16"
  }
}

stack "stg" {
  source = "${get_repo_root()}/catalog/stacks/env"
  path   = "stg"

  values = {
    environment    = "stg"
    aws_account_id = "222222222222"
    aws_region     = "eu-west-1"
    cidr           = "10.30.0.0/16"

    # Example cross-env reference
    dev_vpc_config_path = "../dev/networking/vpc"
  }
}

stack "prod" {
  source = "${get_repo_root()}/catalog/stacks/env"
  path   = "prod"

  values = {
    environment    = "prod"
    aws_account_id = "333333333333"
    aws_region     = "eu-west-1"
    cidr           = "10.40.0.0/16"

    stg_vpc_config_path = "../stg/networking/vpc"
  }
}
```

After generation:

<FileTree>

* live

  * all

    * .terragrunt-stack/

      * dev/

        .terragrunt-stack/

          * monitoring/...
          * networking/...
          * compute/...

      * stg/

        .terragrunt-stack/

          * monitoring/...
          * networking/...
          * compute/...

      * prod/

        .terragrunt-stack/...

</FileTree>

All environments share the same generated tree.

Relative paths like `../dev/...` or `../stg/...` are stable.

---

## Cross-Environment Dependencies (Unit-Level Only)

Cross-environment references must always be declared inside units using `dependency` blocks.

Stacks only pass `config_path` values.

Example inside a unit:

```hcl
dependency "dev_vpc" {
  config_path = values.dev_vpc_config_path

  mock_outputs = {
    vpc_id = "mock"
  }
  mock_outputs_allowed_terraform_commands = ["validate", "plan"]
}
```

This keeps:

* Stack blueprints declarative.
* Execution wiring inside units.
* Dependency graph explicit and inspectable.

---

## When the “All” Stack Is Justified

Use an “all” stack when:

* You intentionally require cross-environment references.
* You need a single generation boundary.
* You want deterministic relative paths between environments.
* You operate promotion/migration workflows at the Terragrunt layer.

---

## When the “All” Stack Is an Anti-Pattern

Do **not** use an “all” stack when:

* Environments are truly isolated.
* You want strict blast-radius separation.
* Cross-environment references are accidental rather than intentional.
* You expect separate CI pipelines per environment without coordination.

In those cases, prefer one root stack per environment.

---

## Operational Guidance

Treat generation boundary and execution boundary as separate concerns:

* Generation boundary = where you run `terragrunt stack generate`.
* Execution boundary = where you run `terragrunt stack run`.

If you use an “all” stack:

* Keep cross-env references explicit.
* Scope execution carefully (CI should control targeting).
* Avoid implicit coupling between environments.

The “all” stack is a power tool.
Use it when architecture requires it — not by default.